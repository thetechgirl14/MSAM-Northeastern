function [Arref,jb] = rrefgf(A,field)
%RREFGF: Reduced row echelon form, in the multiplicative group of integers modulo field.
%   R = RREFGF(A,field) produces the reduced row echelon form of A in the
%       group of integers defined by field
%
%       It is required that field be a positive integer >1, not exceeding
%       2^31. If field is not prime, then it will often be the case that
%       A is singular in this arithmetic.
%
%   [R,jb] = RREF(A,field) also returns a vector, jb, so that:
%       r = length(jb) is this algorithm's idea of the rank of A,
%       x(jb) are the bound variables in a linear system, Ax = b,
%       A(:,jb) is a basis for the range of A,
%       R(1:r,jb) is the r-by-r identity matrix.
%
%   rrefgf operates in int64 arithmetic, although the output will have
%   the same class as A.
%
% Example 1:
% A = magic(3)
% A =
%      8     1     6
%      3     5     7
%      4     9     2
%      
% In the mutiplicative group induced by modulus of 11, A is full rank.
% [Ar,jb] = rrefgf(A,11)
% Ar =
%      1     0     0
%      0     1     0
%      0     0     1
% jb =
%      1     2     3
%
% The inverse of A in that group is easily obtained by appending an
% identity to A.
% Ar = rrefgf([A,eye(size(A))],11)
% Ar =
%      1     0     0     8    10     7
%      0     1     0     0     1     2
%      0     0     1     6     3     5
%      
% mod(A*Ar(:,4:6),11)
% ans =
%      1     0     0
%      0     1     0
%      0     0     1
%
%   Class support for input A:
%      float: double, single, or any integer class
%
%   See also RANK, ORTH, NULL, QR, SVD.

%   Copyright 1984-2005 The MathWorks, Inc. 
%   Modified by JRD in 2019 to work in the group of integers induced by the modulus field

[m,n] = size(A);

if (field <= 1) || (rem(field,1) ~= 0) || (field > 2^31)
  error('field must be a positive integer greater than 1, not exceeding 2^31.')
end

% convert to int64, but remember how A started.
% int64 will allow us to do all arithmetic on numbers in a
% field generated by a modulus no larger than 2^31, since the product of
% two such integers will not exceed the limits of int64.
Arref = A;
A = int64(A);
field = int64(field);
% reduce A modulo field, just in case
A = mod(A,field);

% is field a prime number? If it is, this makes the code simpler.
isp = isprime(field);

% Loop over the entire matrix.
i = 1;
j = 1;
jb = [];
while (i <= m) && (j <= n)
   % Find value and index of the first non-zero element in column j
   % that is relatively prime to field.
   if isp
     % just find the first non-zero remaining in column j
     k = find(A(i:m,j),1,'first');
   else
     % find the first element remaining in the jth column that has a gcd of
     % 1 with field.
     k = find(gcd(A(i:m,j),field) == 1,1,'first');
   end
   if isempty(k)
     % the remaining column elements are all zero or non-invertible
     % in this field.
     p = 0;
   else
     % an element was found
     k = i + k - 1;
     p = A(k,j);
   end
   
   if (p == 0)
      % The column is negligible, zero it out.
      A(i:m,j) = zeros(m-i+1,1,'int64');
      j = j + 1;
   else
      % Remember column index
      jb = [jb j];
      % Swap i-th and k-th rows.
      A([i k],j:n) = A([k i],j:n);
      % Divide the pivot row by the pivot element. This turns into a 
      % multiply by the modular inverse of the pivot.
      pivinv = minv(p,field);
      A(i,j:n) = mod(A(i,j:n)*pivinv,field);
      % Subtract multiples of the pivot row from all the other rows.
      for k = [1:i-1 i+1:m]
         A(k,j:n) = mod(A(k,j:n) - A(k,j)*A(i,j:n),field);
      end
      i = i + 1;
      j = j + 1;
   end
end

% done. We need to return A to its original class.
Arref(:) = A;

function xinv = minv(x,field)
  % returns the modular inverse of x in the defined field.
  [G,C,~] = gcd(x,field);
  if G ~= 1
    xinv = [];
  else
    % the other outputs [G,C,D]=gcd(x,field) are such that 
    % x*C + field*D = G
    % we don't care about D (the third output), so C gives us the modular
    % inverse of x. Make sure it is reduced though.
    xinv = mod(C,field);
  end
  
  